#  第五章： 子类和继承

主要内容：

### 子类和父类：

继承是一种由已有的类创建新类的机制，利用继承，可以先定义一个共有属性的一般类型，根据一般类再定义特殊的子类，子类一般继承类的属性和行为
并根据需要增加它自己的新的属性和行为

    由继承得到的类称为子类，被继承的类称为父类(超类)，需要读者特别注意的是 
    -  Java不支持多重继承 ，即子类只能有一个父类  (这点与C++ 的不同！)
    
  人们习惯地称子类和父类关系是  "is - a” 关系 
    
  
 #### 子类：
 
 在类的申明中，通过使用extends 来定义一个类的子类：

```
class 子类名 extends 父类名{
  }
```
 
 #### 类的树形结构 ：
 
 如果 C 是 B 的子类，B 又是 A 的子类，习惯上称呼 C 又是 A 的子类
 - 在这个树形结构上 ，JAVA 的类按照继承关系形成树形结构（将类看成树的节点），根节点是 Object类



### 子类的继承性：

类有两种重要的成员：
- 成员变量
- 方法

子类的成员的一部分是子类自己声明、定义的，另一部分是从它的父类继承的：
 那么 ：什么叫做继承呢？
 - 所谓子类继承父类的成员变量作为自己的一个成员变量，就好像它们是在子类中直接声明一样的！
 - 也就是说，一个子类的继承的成员应当是这个类的完全意义的成员，如果子类继父类的方法不能操作父类的某个成员变量，该成员就没有继承！


#### 子类和父类在同一包的继承性：
如果子类和父类在同一包内，那么子类自然地继承了其父类中不是private的成员变量作为自己的成员变量
并且也自然地继承父类中不是private 的方法作为自己的方法，继承的成员变量或方法的访问权限保持不变！

##### 子类和父类不在同一包中的继承性：
当子类和父类不在同一包中，父亲的private 和 友好访问权限的成员变量不会被子类继承，也就是说，
- 子类只继承父类中的 protected 和 public 的访问权限 的 成员变量 和 方法
 ##### 继承关系 的 UML 图：
 
![继承关系的UML](https://user-images.githubusercontent.com/68007558/156925663-2f9e5d41-0afe-4a43-88c3-2a2a9d11839e.jpg)

#### protected 的进一步说明：
（！protected 和 public 的区别：）
如果D类在 D本身中创建了一个对象，  那么该对象总是 “  .   ” 运算符访问继承的自己定义的 protected 变量 和 protect 方法的！
- 如果 在另一个类中 ，例如在Other类中用 D类创建一个对象 object ，该对象通过" . "运算符 访问 protected 变量 和 protect 方法 ： 则权限由下所述
- （1） 对于子类 D 自己声明protected成员变量和方法， 只要 Other类 和 D类在同一包中 ，object 对象就可以访问这些protect成员变量和方法
-   （2） 对于子类 D 从父类继承的 protected 成员变量和方法，需要追溯到这些protected 成员变量或方法所在的祖先类，，列如可能是A类，只要other类和A类在同一个包中，object对象能访问继承的 protected 变量和 protect 变量和方法


### 子类和对象：
5.3.1 子类对象的特点：

- 不仅子类声明的成员变量分配了内存，而且父类的成员变量也都分配了内存空间
- 父类中的private成员变量尽管分配了内存空间，也不作为子类对象的变量，即子类不继承父类的私有变量

父类的友好变量同理：

如果子类和父类不在同一包中，尽管父类友好变量分配了内存空间，但不作为子类对象的变量！
- ↑ 即如果子类和父类不在同一包中，子类不继承父类的友好成员变量


根据上述来看似乎使得一部分内存变成了垃圾，但实际并非如此

 - 子类还有一部分方法是从父类继承的，这部分方法可以操作这部分未继承的变量。



### 关于 instanceof 运算符：

instanceof 运算符 是 JAVA 独有的双目运算符，左面操作元是对象，右面的操作元是类
如：
```
zhang instanceof UniverStudent  = false # zhang 不是大学生 
```


## 成员变量和隐藏方法重写：

### 成员变量的隐藏：

在编写子类时， 我们仍然可以声明自己的成员变量，一种特殊情况 ，所声明的成员变量的名字和父类继承的名字相同（声明的类型可以不同）
在这种情况下，子类就会隐藏所继承的成员变量。

子类隐藏继承的成员变量有以下特点：

- 子类对象以及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量
 
- 子类对象仍然可以调用从父类继承的方法操作被子类隐藏的成员变量，也就是说 ，子类继承的方法所操作的成员变量一定是被子类继承和隐藏的成员变量


### 方法重写：

子类通过重写可以隐藏已继承的方法（方法重写也被称为方法覆盖）

#### 重写的语法规则：


如果子类可以继承父类的某个方法，那么子类就有权利重写这个方法
- 并且这个方法的名字 ，参数个数，参数的类型和父亲的方法完全相同，子类如此定义的方法称为子类重写的方法

#### 重写的目的：

子类通过方法的重写可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变成自身的状态和行为

重写方法即可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员，变量、调用新定义的其他方法，但无法子类隐藏的成员变量和方法

- 如果子类使用被隐藏的方法或成员变量，必须使用关键字 super
- 子类重写父类的方法的定义 应当完全相同（类型 名字  参数），如果某项不同就会导致报错
- 子类在重写可继承的方法时，可以完全按照自己的意图编写新的方法体，以便体现写方法的独特行为
- 重写的方法不允许降低方法的访问权限，但可以提高访问权限（访问限制修饰符按访问权限排列顺序是 ： public protected 友好的 private）


### Super 关键字：

#### 用supaer操作被隐藏的成员变量和方法：

子类一旦隐藏了继承的成员变量，那么子类创建的对象就不再拥有该变量，该变量归关键字super所拥有：

- 方法体调用由关键字super负责 : 如

```
super.x       // 访问被子类隐藏的成员变量 x
super.play() // 访问被子类隐藏的方法play（）
```
#### 使用super 调用父类的构造方法：

由于子类不能继承父类的构造方法，子类要在其构造方法中需使用super来调用其构造方法（只有一个构造方法）
```
super(XXX,XXX);
```

当子类的构造方法创建一个子类对象时，子类的构造方法总是先调用父类的某个构造方法

- 如果子类没有明显的指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法 （注意哈 ：是不带参数）


如果类中有多个构造方法，那么JAVA不提供默认的构造方法（不带参数的构造方法），因此，当父类中定义多个构造方法时。
应当包括一个不带参数的构造方法，以防止省略super出现错误


### Final 关键字：

- final 中文意思 ：最终

final 关键字 可以修饰 类、成员变量 、方法的局部变量  ！

#### 常量：

如果成员变量或局部变量被修饰成了 final ，那它就是常量，由于常量在运行过程中不允许再发生变化
- 所以常量在声明时候没有默认值，这就要求程序在声明常量的时候必须指定该常量的值。





































