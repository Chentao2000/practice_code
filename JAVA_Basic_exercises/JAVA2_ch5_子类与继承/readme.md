#  第五章： 子类和继承

主要内容：

### 子类和父类：

继承是一种由已有的类创建新类的机制，利用继承，可以先定义一个共有属性的一般类型，根据一般类再定义特殊的子类，子类一般继承类的属性和行为
并根据需要增加它自己的新的属性和行为

    由继承得到的类称为子类，被继承的类称为父类(超类)，需要读者特别注意的是 
    -  Java不支持多重继承 ，即子类只能有一个父类  (这点与C++ 的不同！)
    
  人们习惯地称子类和父类关系是  "is - a” 关系 
    
  
 #### 子类：
 
 在类的申明中，通过使用extends 来定义一个类的子类：

```
class 子类名 extends 父类名{
  }
```
 
 #### 类的树形结构 ：
 
 如果 C 是 B 的子类，B 又是 A 的子类，习惯上称呼 C 又是 A 的子类
 - 在这个树形结构上 ，JAVA 的类按照继承关系形成树形结构（将类看成树的节点），根节点是 Object类



### 子类的继承性：

类有两种重要的成员：
- 成员变量
- 方法

子类的成员的一部分是子类自己声明、定义的，另一部分是从它的父类继承的：
 那么 ：什么叫做继承呢？
 - 所谓子类继承父类的成员变量作为自己的一个成员变量，就好像它们是在子类中直接声明一样的！
 - 也就是说，一个子类的继承的成员应当是这个类的完全意义的成员，如果子类继父类的方法不能操作父类的某个成员变量，该成员就没有继承！


#### 子类和父类在同一包的继承性：
如果子类和父类在同一包内，那么子类自然地继承了其父类中不是private的成员变量作为自己的成员变量
并且也自然地继承父类中不是private 的方法作为自己的方法，继承的成员变量或方法的访问权限保持不变！

##### 子类和父类不在同一包中的继承性：
当子类和父类不在同一包中，父亲的private 和 友好访问权限的成员变量不会被子类继承，也就是说，
- 子类只继承父类中的 protected 和 public 的访问权限 的 成员变量 和 方法
 ##### 继承关系 的 UML 图：
 
![继承关系的UML](https://user-images.githubusercontent.com/68007558/156925663-2f9e5d41-0afe-4a43-88c3-2a2a9d11839e.jpg)

#### protected 的进一步说明：
（！protected 和 public 的区别：）
如果D类在 D本身中创建了一个对象，  那么该对象总是 “  .   ” 运算符访问继承的自己定义的 protected 变量 和 protect 方法的！
- 如果 在另一个类中 ，例如在Other类中用 D类创建一个对象 object ，该对象通过" . "运算符 访问 protected 变量 和 protect 方法 ： 则权限由下所述
- （1） 对于子类 D 自己声明protected成员变量和方法， 只要 Other类 和 D类在同一包中 ，object 对象就可以访问这些protect成员变量和方法
-   （2） 对于子类 D 从父类继承的 protected 成员变量和方法，需要追溯到这些protected 成员变量或方法所在的祖先类，，列如可能是A类，只要other类和A类在同一个包中，object对象能访问继承的 protected 变量和 protect 变量和方法


### 子类和对象：
5.3.1 子类对象的特点：

- 不仅子类声明的成员变量分配了内存，而且父类的成员变量也都分配了内存空间
- 父类中的private成员变量尽管分配了内存空间，也不作为子类对象的变量，即子类不继承父类的私有变量

父类的友好变量同理：

如果子类和父类不在同一包中，尽管父类友好变量分配了内存空间，但不作为子类对象的变量！
- ↑ 即如果子类和父类不在同一包中，子类不继承父类的友好成员变量


根据上述来看似乎使得一部分内存变成了垃圾，但实际并非如此

 - 子类还有一部分方法是从父类继承的，这部分方法可以操作这部分未继承的变量。










