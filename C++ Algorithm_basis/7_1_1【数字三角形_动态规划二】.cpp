/******************************************************************************
 第 7 章 ： 动态规划 二
    
    
    第二种解题思路：
        
        第一种程序效率非常的的低，在 N 值并不大，例如 N = 100 时，就慢的几乎不可能算出结果
        整个 程序 复杂度 是 O(2N)
    
    第二种解体思路 ：
        当唯有一个值一旦计算出来就将被进行记录，以避免后续不必要的重复计算 
        即第一次算出MaxSum(r,j) 的值就将该值存放出来，下次再需要计算 
        MaxSum（r,j）时候，直接取出已保存的值就可，不必再强调MaxSum（）进行函数递归计算
        这样每个Maxsum（r,j）都只需要计算一次就可，不必再调用MaxSum（），
        那么总的计算次数 是  1 + 2 + 3 + 4 + .... + N = N x (N + 1)/2N
        
*******************************************************************************/
#include <iostream>
#include <cstdio>
#include <cstring>

using  namespace std;

#define MAX_NUM 100
int d[MAX_NUM + 10][MAX_NUM +10];
int N;
int maxSum[MAX_NUM + 10][MAX_NUM + 10];

int MaxSum(int r,int j){
    if(r == N)
        return d[r][j];
        // 如果 MaxSum (r + 1 , j )没有计算过
    
    if(maxSum[r + 1][j] == -1)
        maxSum[r + 1][j] = MaxSum(r + 1, j);
        
    if(maxSum[r+1][j+1] == -1)
        maxSum[r+1][j+1] = MaxSum(r + 1, j + 1 );
    
    if(maxSum[r + 1][j] > maxSum[r + 1][ j + 1])
        return maxSum[r + 1][j] + d[r][j];
        
    return maxSum[r+ 1][j + 1] + d[r][j]; 
} 
int main()
{
    int m;
    scanf("%d",&N);
    N = N + 1; //这一行是自己加上去的 
    
    // 如果将 maxsum全部置成 -1,则表示开始所有的 MaxSum(r,j)都没有计算过
    memset(maxSum,-1,sizeof(maxSum));
    for (int i = 1; i <= N; i++) 
        for (int j = 1; j < i; j++) 
        scanf("%d",&d[i][j]);
        
    printf("%d",MaxSum(1,1));
    return 0;    
}


/******************************************************************************

        问题描述 ：     7 
                    3       8
                8       1      0
            2       7       4       4
        4       5       2       6       5
        
        上面给出了一个数字三角形，从三角形顶部到底部有多少各不同的路径
        对于每条路径，把路径上面的数加起来可以得到一个和，累加和最大的路径被称为“最短路径”
        题目的任务 就是求出最佳路径上的数字之和
        
        输入数据 ： 第一行是一个整数 N , 给出三角形的行数，下面的 N 行给出数字三角形，
        数字三角形中的数的范围都在 0 ~ 100 之间
        
        输出数据： 输出最大的和
        
        输入样例 5 
                7 
               3  8
              8   1   0 
             2    7   4   4
            4     5   2    6  5
*******************************************************************************/

